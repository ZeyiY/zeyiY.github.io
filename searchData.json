[{"title":"MEM的英语","url":"/2019/04/22/MEM的英语/","content":"\n五大基本类型：\n\nI love you.\n\nThe sun rises.\n\nI give you a book.\n\nI make you happy.\n\nI am happy."},{"title":"JAVA插件Lombok的使用持续更新","url":"/2019/04/17/JAVA插件Lombok的使用持续更新/","content":"\n##@Data\n\n\n\n##@Setter\n\n\n\n##@Getter\n\n\n\n##@EqualsAndHashCode\n\n\n\n##@ToString\n\n"},{"title":"这些年Mybatis使用PageHelper进行分页掉的下水井以及填井盖","url":"/2019/04/13/这些年Mybatis使用PageHelper进行分页掉的下水井以及填井盖/","content":"\n## 这些年Mybatis使用PageHelper进行分页掉的下水井以及填井盖\n\n#### 前言\n\n日常业务开发中，列表分页查询的需求非常常见，在Mybatis 架构中，我们又非常喜欢使用[PageHelper](https://github.com/pagehelper/Mybatis-PageHelper) 这个插件，非常感谢开源这个插件的大佬～\n\n虽然大佬把文档写的非常全，然而依然掉下水井🤦‍♂️，以下记录一下掉的下水井，以及如何填井盖的过程。\n\n[使用文档](https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md>)一定要仔细看，填盖过程中引用了文档的相关内容。\n\n#### 问题描述\n\n在单元测试测试和测试环境中分别出现了两个问题，让我怀疑了人生。\n\n单元测试问题：\n\n查询报错，无缘无故的加了一个order by 排序，查看sql 和 方法并没有order by的逻辑，并且没有其他的逻辑(也没有PageHelper 配置)，真的活见鬼了，最见鬼的是非必现。\n\n测试环境问题：\n\n程序执行一段时间后，一个分页接口直接报错了，报错的内容见下图，同样是非现，代码也没有特殊的逻辑，一个查询，使用PageHelper.startPage(pageNum, pageSize)进行分页。\n\n```\n报错信息：\n09:41:22.528 [http-nio-8080-exec-1] ERROR o.a.c.c.C.[.[.[.[dispatcherServlet] - Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.type.TypeException: Could not set parameters for mapping: ParameterMapping{property='Second_PageHelper', mode=IN, javaType=class java.lang.Integer, jdbcType=null, numericScale=null, resultMapId='null', jdbcTypeName='null', expression='null'}. Cause: org.apache.ibatis.type.TypeException: Error setting non null for parameter #1 with JdbcType null . Try setting a different JdbcType for this parameter or a different configuration property. Cause: java.sql.SQLException: Type not supported] with root cause\njava.sql.SQLException: Type not supported\nat com.informix.util.IfxErrMsg.buildException(IfxErrMsg.java:480)\nat com.informix.util.IfxErrMsg.getSQLException(IfxErrMsg.java:449)\nat com.informix.util.IfxErrMsg.getSQLException(IfxErrMsg.java:400)\nat com.informix.jdbc.IfxValue.getIfxTypeName(IfxValue.java:207)\nat com.informix.jdbc.IfxValue.makeInstance(IfxValue.java:342)\nat com.informix.jdbc.IfxValue.makeInstance(IfxValue.java:334)\nat com.informix.jdbc.IfxPreparedStatement.setInt(IfxPreparedStatement.java:989)\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:498)\nat org.apache.tomcat.jdbc.pool.StatementFacade$StatementProxy.invoke(StatementFacade.java:114)\nat com.sun.proxy.$Proxy133.setInt(Unknown Source)\nat org.apache.ibatis.type.IntegerTypeHandler.setNonNullParameter(IntegerTypeHandler.java:31)\nat org.apache.ibatis.type.IntegerTypeHandler.setNonNullParameter(IntegerTypeHandler.java:26)\nat org.apache.ibatis.type.BaseTypeHandler.setParameter(BaseTypeHandler.java:53)\nat org.apache.ibatis.scripting.defaults.DefaultParameterHandler.setParameters(DefaultParameterHandler.java:87)\nat org.apache.ibatis.executor.statement.PreparedStatementHandler.parameterize(PreparedStatementHandler.java:93)\nat org.apache.ibatis.executor.statement.RoutingStatementHandler.parameterize(RoutingStatementHandler.java:64)\nat org.apache.ibatis.executor.SimpleExecutor.prepareStatement(SimpleExecutor.java:86)\nat org.apache.ibatis.executor.SimpleExecutor.doQuery(SimpleExecutor.java:62)\nat org.apache.ibatis.executor.BaseExecutor.queryFromDatabase(BaseExecutor.java:326)\nat org.apache.ibatis.executor.BaseExecutor.query(BaseExecutor.java:156)\nat org.apache.ibatis.executor.CachingExecutor.query(CachingExecutor.java:109)\nat com.github.pagehelper.PageInterceptor.intercept(PageInterceptor.java:136)\nat org.apache.ibatis.plugin.Plugin.invoke(Plugin.java:61)\nat com.sun.proxy.$Proxy131.query(Unknown Source)\nat org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:148)\nat org.apache.ibatis.session.defaults.DefaultSqlSession.selectList(DefaultSqlSession.java:141)\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:498)\nat org.mybatis.spring.SqlSessionTemplate$SqlSessionInterceptor.invoke(SqlSessionTemplate.java:433)\nat com.sun.proxy.$Proxy81.selectList(Unknown Source)\nat org.mybatis.spring.SqlSessionTemplate.selectList(SqlSessionTemplate.java:230)\nat org.apache.ibatis.binding.MapperMethod.executeForMany(MapperMethod.java:139)\nat org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:76)\nat org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:59)\nat com.sun.proxy.$Proxy87.selectByExample(Unknown Source)\nat com.ccb.hebei.zcyd.dao.service.impl.ContractRecordStateServiceImpl.search(ContractRecordStateServiceImpl.java:50)\nat com.ccb.hebei.zcyd.web.api.RecordStateApi.search(RecordStateApi.java:42)\nat sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\nat sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\nat sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\nat java.lang.reflect.Method.invoke(Method.java:498)\nat org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:205)\nat org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:133)\nat org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:97)\nat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:827)\nat org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:738)\nat org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85)\nat org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:967)\nat org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:901)\nat org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:970)\nat org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:872)\nat javax.servlet.http.HttpServlet.service(HttpServlet.java:661)\nat org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:846)\nat javax.servlet.http.HttpServlet.service(HttpServlet.java:742)\nat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:231)\nat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\nat org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:52)\nat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\nat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\nat org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:99)\nat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\nat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\nat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\nat org.springframework.web.filter.HttpPutFormContentFilter.doFilterInternal(HttpPutFormContentFilter.java:109)\nat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\nat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\nat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\nat org.springframework.web.filter.HiddenHttpMethodFilter.doFilterInternal(HiddenHttpMethodFilter.java:81)\nat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\nat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\nat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\nat org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:197)\nat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)\nat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:193)\nat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:166)\nat org.apache.catalina.core.StandardWrapperValve.invoke(StandardWrapperValve.java:198)\nat org.apache.catalina.core.StandardContextValve.invoke(StandardContextValve.java:96)\nat org.apache.catalina.authenticator.AuthenticatorBase.invoke(AuthenticatorBase.java:496)\nat org.apache.catalina.core.StandardHostValve.invoke(StandardHostValve.java:140)\nat org.apache.catalina.valves.ErrorReportValve.invoke(ErrorReportValve.java:81)\nat org.apache.catalina.core.StandardEngineValve.invoke(StandardEngineValve.java:87)\nat org.apache.catalina.connector.CoyoteAdapter.service(CoyoteAdapter.java:342)\nat org.apache.coyote.http11.Http11Processor.service(Http11Processor.java:803)\nat org.apache.coyote.AbstractProcessorLight.process(AbstractProcessorLight.java:66)\nat org.apache.coyote.AbstractProtocol$ConnectionHandler.process(AbstractProtocol.java:790)\nat org.apache.tomcat.util.net.NioEndpoint$SocketProcessor.doRun(NioEndpoint.java:1459)\nat org.apache.tomcat.util.net.SocketProcessorBase.run(SocketProcessorBase.java:49)\nat java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)\nat java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)\nat org.apache.tomcat.util.threads.TaskThread$WrappingRunnable.run(TaskThread.java:61)\nat java.lang.Thread.run(Thread.java:745)\n```\n\n```\n代码模块：\n PageHelper.startPage(pageNum, pageSize);\n list = countryMapper.selectIf(param1);\n```\n\n#### 问题解析\n\n欲解决问题，就要了解PageHelper是怎么实现的，并且PageHelper.startPage(pageNum, pageSize) 干了啥事。\n\n这次现看PageHelper.startPage(pageNum, pageSize)的源码：\n\n```\n\npackage com.github.pagehelper.page;\n\nimport com.github.pagehelper.ISelect;\nimport com.github.pagehelper.Page;\nimport com.github.pagehelper.util.PageObjectUtil;\n\nimport java.util.Properties;\n\n/**\n * 基础分页方法\n *\n * @author liuzh\n */\npublic abstract class PageMethod {\n    protected static final ThreadLocal<Page> LOCAL_PAGE = new ThreadLocal<Page>();\n    protected static boolean DEFAULT_COUNT = true;\n\n    /**\n     * 设置 Page 参数\n     *\n     * @param page\n     */\n    protected static void setLocalPage(Page page) {\n        LOCAL_PAGE.set(page);\n    }\n\n    /**\n     * 获取 Page 参数\n     *\n     * @return\n     */\n    public static <T> Page<T> getLocalPage() {\n        return LOCAL_PAGE.get();\n    }\n\n    /**\n     * 移除本地变量\n     */\n    public static void clearPage() {\n        LOCAL_PAGE.remove();\n    }\n\n    /**\n     * 开始分页\n     *\n     * @param params\n     */\n    public static <E> Page<E> startPage(Object params) {\n        Page<E> page = PageObjectUtil.getPageFromObject(params, true);\n        //当已经执行过orderBy的时候\n        Page<E> oldPage = getLocalPage();\n        if (oldPage != null && oldPage.isOrderByOnly()) {\n            page.setOrderBy(oldPage.getOrderBy());\n        }\n        setLocalPage(page);\n        return page;\n    }\n\n    /**\n     * 开始分页\n     *\n     * @param pageNum  页码\n     * @param pageSize 每页显示数量\n     */\n    public static <E> Page<E> startPage(int pageNum, int pageSize) {\n        return startPage(pageNum, pageSize, DEFAULT_COUNT);\n    }\n\n    /**\n     * 开始分页\n     *\n     * @param pageNum  页码\n     * @param pageSize 每页显示数量\n     * @param count    是否进行count查询\n     */\n    public static <E> Page<E> startPage(int pageNum, int pageSize, boolean count) {\n        return startPage(pageNum, pageSize, count, null, null);\n    }\n\n    /**\n     * 开始分页\n     *\n     * @param pageNum  页码\n     * @param pageSize 每页显示数量\n     * @param orderBy  排序\n     */\n    public static <E> Page<E> startPage(int pageNum, int pageSize, String orderBy) {\n        Page<E> page = startPage(pageNum, pageSize);\n        page.setOrderBy(orderBy);\n        return page;\n    }\n\n    /**\n     * 开始分页\n     *\n     * @param pageNum      页码\n     * @param pageSize     每页显示数量\n     * @param count        是否进行count查询\n     * @param reasonable   分页合理化,null时用默认配置\n     * @param pageSizeZero true且pageSize=0时返回全部结果，false时分页,null时用默认配置\n     */\n    public static <E> Page<E> startPage(int pageNum, int pageSize, boolean count, Boolean reasonable, Boolean pageSizeZero) {\n        Page<E> page = new Page<E>(pageNum, pageSize, count);\n        page.setReasonable(reasonable);\n        page.setPageSizeZero(pageSizeZero);\n        //当已经执行过orderBy的时候\n        Page<E> oldPage = getLocalPage();\n        if (oldPage != null && oldPage.isOrderByOnly()) {\n            page.setOrderBy(oldPage.getOrderBy());\n        }\n        setLocalPage(page);\n        return page;\n    }\n.....忽略了一些代码........\n}\n\n```\n\n发现PageHelper中使用ThreadLocal，ThreadLocal有什么特性呢？详情请看下篇[文章](https://zeyiy.github.io/2019/04/13/ThreadLocal%E7%9A%84%E7%90%86%E8%A7%A3/)讲解。先说结论，\n\n结论是：分页参数和线程是绑定的。\n\n只要你可以保证在 `PageHelper` 方法调用后紧跟 MyBatis 查询方法，这就是安全的。因为 `PageHelper` 在 `finally` 代码段中自动清除了 `ThreadLocal` 存储的对象。\n\n如果代码在进入 `Executor` 前发生异常，就会导致线程不可用，这属于人为的 Bug（例如接口方法和 XML 中的不匹配，导致找不到 `MappedStatement` 时）， 这种情况由于线程不可用，也不会导致 `ThreadLocal` 参数被错误的使用。\n\n不安全的代码示范：\n\n```\nPageHelper.startPage(1, 10);\nList<Country> list;\nif(param1 != null){\n    list = countryMapper.selectIf(param1);\n} else {\n    list = new ArrayList<Country>();\n}\n```\n\n这种情况下由于 param1 存在 null 的情况，就会导致 PageHelper 生产了一个分页参数，但是没有被消费，这个参数就会一直保留在这个线程上。当这个线程再次被使用时，就可能导致不该分页的方法去消费这个分页参数，这就产生了莫名其妙的分页。\n\n同样orderBy同理。\n\n查看全局代码发现，确实有这样的代码逻辑🤦‍♂️。这同时解释了为啥不是必现的原因了，因为触发未消费的分页参数的逻辑不是每次都执行。\n\n#### 怎么填井盖呢？\n\n1. PageHelper 紧跟查询语句\n\n```\nList<Country> list;\nif(param1 != null){\n    PageHelper.startPage(1, 10);\n    list = countryMapper.selectIf(param1);\n} else {\n    list = new ArrayList<Country>();\n}\n```\n\n2. 在使用完之后手动清空ThreadLocal 存储的信息\n\n```\nPageHelper.clearPage();\n```\n\n3. Java8 lambda用法\n\n```\nPage<Country> page = PageHelper.startPage(1, 10).doSelectPage(()-> countryMapper.selectGroupBy());\n\nPageInfo<Country> pageInfo = PageHelper.startPage(1, 10).doSelectPageInfo(() -> countryMapper.selectGroupBy());\n```\n\n"},{"title":"ThreadLocal的理解","url":"/2019/04/13/ThreadLocal的理解/","content":"\n## ThreadLocal 源码解析、使用场景介绍、注意事项等\n\n#### 前言\n\nThreadLocal 是什么呢？它是一个本地线程副本变量工具类，用于提供线程局部变量。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰。例如：用户ID或事务ID。\n\n#### ThreadLocal实现的数据结构\n\n\n\n#### 源码\n\n```\npackage java.lang;\nimport java.lang.ref.*;\nimport java.util.Objects;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Supplier;\n\npublic class ThreadLocal<T> {\n    \n    private final int threadLocalHashCode = nextHashCode();\n    \n    private static AtomicInteger nextHashCode = new AtomicInteger();\n\n    private static final int HASH_INCREMENT = 0x61c88647;\n\n    private static int nextHashCode() {\n        return nextHashCode.getAndAdd(HASH_INCREMENT);\n    }\n\n    protected T initialValue() {\n        return null;\n    }\n\n    public static <S> ThreadLocal<S> withInitial(Supplier<? extends S> supplier) {\n        return new SuppliedThreadLocal<>(supplier);\n    }\n\n   \n    public ThreadLocal() {\n    }\n\n    /**\n     * 1.获取当前线程的ThreadLocalMap对象threadLocals\n     * 2.从map中获取线程存储的K-V Entry节点。\n     * 3.从Entry节点获取存储的Value副本值返回。\n     * 4.map为空的话返回初始值null，即线程变量副本为null，在使用时需要注意判断NullPointerException。\n     */\n    public T get() {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null) {\n            ThreadLocalMap.Entry e = map.getEntry(this);\n            if (e != null) {\n                @SuppressWarnings(\"unchecked\")\n                T result = (T)e.value;\n                return result;\n            }\n        }\n        return setInitialValue();\n    }\n\n\n    private T setInitialValue() {\n        T value = initialValue();\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n        return value;\n    }\n\n    /**\n     * 1.获取当前线程的成员变量map\n     * 2.map非空，则重新将ThreadLocal和新的value副本放入到map中。\n     * 3.map空，则对线程的成员变量ThreadLocalMap进行初始化创建，并将ThreadLocal和value副本放入map中。\n     */\n    public void set(T value) {\n        Thread t = Thread.currentThread();\n        ThreadLocalMap map = getMap(t);\n        if (map != null)\n            map.set(this, value);\n        else\n            createMap(t, value);\n    }\n\n\n     public void remove() {\n         ThreadLocalMap m = getMap(Thread.currentThread());\n         if (m != null)\n             m.remove(this);\n     }\n\n    \n    ThreadLocalMap getMap(Thread t) {\n        return t.threadLocals;\n    }\n\n\n    void createMap(Thread t, T firstValue) {\n        t.threadLocals = new ThreadLocalMap(this, firstValue);\n    }\n\n\n    static ThreadLocalMap createInheritedMap(ThreadLocalMap parentMap) {\n        return new ThreadLocalMap(parentMap);\n    }\n\n\n    T childValue(T parentValue) {\n        throw new UnsupportedOperationException();\n    }\n\n\n    static final class SuppliedThreadLocal<T> extends ThreadLocal<T> {\n\n        private final Supplier<? extends T> supplier;\n\n        SuppliedThreadLocal(Supplier<? extends T> supplier) {\n            this.supplier = Objects.requireNonNull(supplier);\n        }\n\n        @Override\n        protected T initialValue() {\n            return supplier.get();\n        }\n    }\n\n\n    static class ThreadLocalMap {\n\n     \n        static class Entry extends WeakReference<ThreadLocal<?>> {\n            \n            Object value;\n\n            Entry(ThreadLocal<?> k, Object v) {\n                super(k);\n                value = v;\n            }\n        }\n\n       \n        private static final int INITIAL_CAPACITY = 16;\n\n        \n        private Entry[] table;\n\n      \n        private int size = 0;\n\n        \n        private int threshold; // Default to 0\n\n        \n        private void setThreshold(int len) {\n            threshold = len * 2 / 3;\n        }\n\n        \n        private static int nextIndex(int i, int len) {\n            return ((i + 1 < len) ? i + 1 : 0);\n        }\n\n       \n        private static int prevIndex(int i, int len) {\n            return ((i - 1 >= 0) ? i - 1 : len - 1);\n        }\n\n        \n        ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {\n            table = new Entry[INITIAL_CAPACITY];\n            int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);\n            table[i] = new Entry(firstKey, firstValue);\n            size = 1;\n            setThreshold(INITIAL_CAPACITY);\n        }\n\n        \n        private ThreadLocalMap(ThreadLocalMap parentMap) {\n            Entry[] parentTable = parentMap.table;\n            int len = parentTable.length;\n            setThreshold(len);\n            table = new Entry[len];\n\n            for (int j = 0; j < len; j++) {\n                Entry e = parentTable[j];\n                if (e != null) {\n                    @SuppressWarnings(\"unchecked\")\n                    ThreadLocal<Object> key = (ThreadLocal<Object>) e.get();\n                    if (key != null) {\n                        Object value = key.childValue(e.value);\n                        Entry c = new Entry(key, value);\n                        int h = key.threadLocalHashCode & (len - 1);\n                        while (table[h] != null)\n                            h = nextIndex(h, len);\n                        table[h] = c;\n                        size++;\n                    }\n                }\n            }\n        }\n\n        \n        private Entry getEntry(ThreadLocal<?> key) {\n            int i = key.threadLocalHashCode & (table.length - 1);\n            Entry e = table[i];\n            if (e != null && e.get() == key)\n                return e;\n            else\n                return getEntryAfterMiss(key, i, e);\n        }\n\n        private Entry getEntryAfterMiss(ThreadLocal<?> key, int i, Entry e) {\n            Entry[] tab = table;\n            int len = tab.length;\n\n            while (e != null) {\n                ThreadLocal<?> k = e.get();\n                if (k == key)\n                    return e;\n                if (k == null)\n                    expungeStaleEntry(i);\n                else\n                    i = nextIndex(i, len);\n                e = tab[i];\n            }\n            return null;\n        }\n\n        private void set(ThreadLocal<?> key, Object value) {\n\n            Entry[] tab = table;\n            int len = tab.length;\n            int i = key.threadLocalHashCode & (len-1);\n\n            for (Entry e = tab[i];\n                 e != null;\n                 e = tab[i = nextIndex(i, len)]) {\n                ThreadLocal<?> k = e.get();\n\n                if (k == key) {\n                    e.value = value;\n                    return;\n                }\n\n                if (k == null) {\n                    replaceStaleEntry(key, value, i);\n                    return;\n                }\n            }\n\n            tab[i] = new Entry(key, value);\n            int sz = ++size;\n            if (!cleanSomeSlots(i, sz) && sz >= threshold)\n                rehash();\n        }\n\n        private void remove(ThreadLocal<?> key) {\n            Entry[] tab = table;\n            int len = tab.length;\n            int i = key.threadLocalHashCode & (len-1);\n            for (Entry e = tab[i];\n                 e != null;\n                 e = tab[i = nextIndex(i, len)]) {\n                if (e.get() == key) {\n                    e.clear();\n                    expungeStaleEntry(i);\n                    return;\n                }\n            }\n        }\n\n        private void replaceStaleEntry(ThreadLocal<?> key, Object value,\n                                       int staleSlot) {\n            Entry[] tab = table;\n            int len = tab.length;\n            Entry e;\n\n            int slotToExpunge = staleSlot;\n            for (int i = prevIndex(staleSlot, len);\n                 (e = tab[i]) != null;\n                 i = prevIndex(i, len))\n                if (e.get() == null)\n                    slotToExpunge = i;\n\n            for (int i = nextIndex(staleSlot, len);\n                 (e = tab[i]) != null;\n                 i = nextIndex(i, len)) {\n                ThreadLocal<?> k = e.get();\n\n\n                if (k == key) {\n                    e.value = value;\n\n                    tab[i] = tab[staleSlot];\n                    tab[staleSlot] = e;\n\n                    if (slotToExpunge == staleSlot)\n                        slotToExpunge = i;\n                    cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);\n                    return;\n                }\n\n                if (k == null && slotToExpunge == staleSlot)\n                    slotToExpunge = i;\n            }\n\n            tab[staleSlot].value = null;\n            tab[staleSlot] = new Entry(key, value);\n\n            if (slotToExpunge != staleSlot)\n                cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);\n        }\n\n        private int expungeStaleEntry(int staleSlot) {\n            Entry[] tab = table;\n            int len = tab.length;\n\n            // expunge entry at staleSlot\n            tab[staleSlot].value = null;\n            tab[staleSlot] = null;\n            size--;\n\n            // Rehash until we encounter null\n            Entry e;\n            int i;\n            for (i = nextIndex(staleSlot, len);\n                 (e = tab[i]) != null;\n                 i = nextIndex(i, len)) {\n                ThreadLocal<?> k = e.get();\n                if (k == null) {\n                    e.value = null;\n                    tab[i] = null;\n                    size--;\n                } else {\n                    int h = k.threadLocalHashCode & (len - 1);\n                    if (h != i) {\n                        tab[i] = null;\n\n                        // Unlike Knuth 6.4 Algorithm R, we must scan until\n                        // null because multiple entries could have been stale.\n                        while (tab[h] != null)\n                            h = nextIndex(h, len);\n                        tab[h] = e;\n                    }\n                }\n            }\n            return i;\n        }\n\n       \n        private boolean cleanSomeSlots(int i, int n) {\n            boolean removed = false;\n            Entry[] tab = table;\n            int len = tab.length;\n            do {\n                i = nextIndex(i, len);\n                Entry e = tab[i];\n                if (e != null && e.get() == null) {\n                    n = len;\n                    removed = true;\n                    i = expungeStaleEntry(i);\n                }\n            } while ( (n >>>= 1) != 0);\n            return removed;\n        }\n\n\n        private void rehash() {\n            expungeStaleEntries();\n\n            if (size >= threshold - threshold / 4)\n                resize();\n        }\n\n        private void resize() {\n            Entry[] oldTab = table;\n            int oldLen = oldTab.length;\n            int newLen = oldLen * 2;\n            Entry[] newTab = new Entry[newLen];\n            int count = 0;\n\n            for (int j = 0; j < oldLen; ++j) {\n                Entry e = oldTab[j];\n                if (e != null) {\n                    ThreadLocal<?> k = e.get();\n                    if (k == null) {\n                        e.value = null; // Help the GC\n                    } else {\n                        int h = k.threadLocalHashCode & (newLen - 1);\n                        while (newTab[h] != null)\n                            h = nextIndex(h, newLen);\n                        newTab[h] = e;\n                        count++;\n                    }\n                }\n            }\n\n            setThreshold(newLen);\n            size = count;\n            table = newTab;\n        }\n\n        private void expungeStaleEntries() {\n            Entry[] tab = table;\n            int len = tab.length;\n            for (int j = 0; j < len; j++) {\n                Entry e = tab[j];\n                if (e != null && e.get() == null)\n                    expungeStaleEntry(j);\n            }\n        }\n    }\n}\n```\n\n#### 结构图\n\n![image-20190415225125426](/Users/jingshuo/Library/Application Support/typora-user-images/image-20190415225125426.png)\n\n从上面的结构图，我们已经窥见ThreadLocal的核心机制：\n\n- 每个Thread线程内部都有一个Map。\n- Map里面存储线程本地对象（key）和线程的变量副本（value）\n- 但是，Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。\n\n所以对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。\n\n- get()方法用于获取当前线程的副本变量值。\n- set()方法用于保存当前线程的副本变量值。\n- initialValue()为当前线程初始副本变量值。\n- remove()方法移除当前前程的副本变量值。"},{"title":"Mybatis的if-else","url":"/2019/04/10/Mybatis的if-else/","content":"\n## Mybatis的if-else\n\n#### mybaits 中没有else要用chose when otherwise 代替\n\n表示方法：\n\n```\n<choose>\n    <when test=\"\">\n        //...\n    </when>\n    <otherwise>\n        //...\n    </otherwise>\n</choose>\n```\n\nchoose为一个整体 \nwhen是if \notherwise是else\n\n示例：\n\n```\n<select id=\"selectSelective\" resultMap=\"xxx\" parameterType=\"xxx\">\n    select\n    <include refid=\"Base_Column_List\"/>\n    from xxx\n    where del_flag=0\n    <choose>\n        <when test=\"xxx !=null and xxx != ''\">\n            and xxx like concat(concat('%', #{xxx}), '%')\n        </when>\n        <otherwise>\n            and xxx like '**%'\n        </otherwise>\n    </choose>\n</select>\n```\n\n"},{"title":"SpringBoot的maven-git-commit-id-plugin使用","url":"/2019/04/09/SpringBoot的maven-git-commit-id-plugin使用/","content":"\n## Spring boot的maven-git-commit-id-plugin使用\n\n#### 背景\n\n在日常开发部署过程中，您是否遇到以下问题，多人合作时，测试环境不知道部署的哪个分支，测试同学也不清楚如何提bug？线上出现紧急bug，代码也不知道在哪个tag出的问题？是不是我们紧急需要一个接口能够清楚的知道部署的分支是哪个分支，谁部署的呢？这篇文章就是通过一个配置  *Maven git commit id插件*并创建Web服务。在此之后，版本信息会在每次构建过程中自动更新。\n\n###git commit id插件\n\n所有属性的详细信息可以在git commit id插件的[GitHub](https://github.com/ktoso/maven-git-commit-id-plugin)存储库中找到。\n\n1. 添加pom配置，插件部分\n\n```\n<plugin>\n    <groupId>pl.project13.maven</groupId>\n    <artifactId>git-commit-id-plugin</artifactId>\n    <version>2.2.4</version>\n    <executions>\n        <execution>\n            <id>get-the-git-infos</id>\n            <goals>\n                <goal>revision</goal>\n            </goals>\n        </execution>\n    </executions>\n    <configuration>\n        <dotGitDirectory>${project.basedir}/.git</dotGitDirectory>\n        <prefix>git</prefix>\n        <verbose>false</verbose>\n        <generateGitPropertiesFile>true</generateGitPropertiesFile>\n    <generateGitPropertiesFilename>${project.build.outputDirectory}/git.properties</generateGitPropertiesFilename>\n        <format>json</format>\n        <gitDescribe>\n            <skip>false</skip>\n            <always>false</always>\n            <dirty>-dirty</dirty>\n        </gitDescribe>\n    </configuration>\n</plugin>\n```\n\n2. 运行maven build 构建，在targer/classes中，git.properties 文件中添加了JSON格式的版本信息\n\n```\n{\n  \"git.branch\" : \"master\",\n  \"git.build.host\" : \"jingshuodeMacBook-Pro-3.local\",\n  \"git.build.time\" : \"2019-04-07T13:00:13+0800\",\n  \"git.build.user.email\" : \"\",\n  \"git.build.user.name\" : \"\",\n  \"git.build.version\" : \"0.0.1-SNAPSHOT\",\n  \"git.closest.tag.commit.count\" : \"\",\n  \"git.closest.tag.name\" : \"\",\n  \"git.commit.id\" : \"6c6c0fbc1bc18a853d0b9b9361d95e61439f0cac\",\n  \"git.commit.id.abbrev\" : \"6c6c0fb\",\n  \"git.commit.id.describe\" : \"6c6c0fb\",\n  \"git.commit.id.describe-short\" : \"6c6c0fb\",\n  \"git.commit.message.full\" : \"Merge pull request #4 from nebulacollection/develop\\n\\nfeat:添加git commit 插件以及接口，便于打包时可以确定当前打包版本\",\n  \"git.commit.message.short\" : \"Merge pull request #4 from nebulacollection/develop\",\n  \"git.commit.time\" : \"2019-03-11T00:26:47+0800\",\n  \"git.commit.user.email\" : \"15763942407@163.com\",\n  \"git.commit.user.name\" : \"ZeyiY\",\n  \"git.dirty\" : \"false\",\n  \"git.remote.origin.url\" : \"https://github.com/nebulacollection/NebulaCollectionApi.git\",\n  \"git.tags\" : \"\"\n}\n```\n\n3. 版本信息添加到RESTful 接口中\n\n我们要做的就是读取git.properties 返回到接口中\n\n```\n@RestController\npublic class VersionController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(VersionController.class);\n\n\n    @RequestMapping(value = \"/version\", method = GET)\n    public String versionInformation() {\n        return readGitProperties();\n    }\n\n    private String readGitProperties() {\n        try {\n            ClassLoader classLoader = getClass().getClassLoader();\n            InputStream inputStream = classLoader.getResourceAsStream(\"git.properties\");\n            return readFromInputStream(inputStream);\n        } catch (IOException e) {\n            LOGGER.error(\"readGitProperties error\", e);\n            return \"Version information could not be retrieved\";\n        }\n    }\n\n    private String readFromInputStream(InputStream inputStream)\n            throws IOException {\n        StringBuilder resultStringBuilder = new StringBuilder();\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(inputStream))) {\n            String line;\n            while ((line = br.readLine()) != null) {\n                resultStringBuilder.append(line).append(\"\\n\");\n            }\n        }\n        return resultStringBuilder.toString();\n    }\n}\n```\n\n构建运行项目，在http:localhost:8080/\n\n```\n@RestController\npublic class VersionController {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(VersionController.class);\n\n\n    @RequestMapping(value = \"/version\", method = GET)\n    public String versionInformation() {\n        return readGitProperties();\n    }\n\n    private String readGitProperties() {\n        try {\n            ClassLoader classLoader = getClass().getClassLoader();\n            InputStream inputStream = classLoader.getResourceAsStream(\"git.properties\");\n            return readFromInputStream(inputStream);\n        } catch (IOException e) {\n            LOGGER.error(\"readGitProperties error\", e);\n            return \"Version information could not be retrieved\";\n        }\n    }\n\n    private String readFromInputStream(InputStream inputStream)\n            throws IOException {\n        StringBuilder resultStringBuilder = new StringBuilder();\n        try (BufferedReader br = new BufferedReader(new InputStreamReader(inputStream))) {\n            String line;\n            while ((line = br.readLine()) != null) {\n                resultStringBuilder.append(line).append(\"\\n\");\n            }\n        }\n        return resultStringBuilder.toString();\n    }\n}\n```\n\n构建运行项目，在http:localhost:8080/version 就可以看到构建信息。\n\n"},{"title":"Java关于空指针的防范与思考","url":"/2019/04/09/Java关于空指针的防范与思考/","content":"\n# Java关于空指针的防范与思考\n\n转自<https://juejin.im/post/5b9cab616fb9a05d30174491>\n\n### 空指针分析\n\n对于空指针的出现，其实一般可以归纳为以下几个原因:\n\n- 对于方法入参没有严格校验\n- 对于方法返回值没有严格的校验\n\n本质原因：\n\n对于调用的其他API没有充分的了解，使用时不知道API方法的入参是否可以接受null，不确定方法的返回值是否为null。\n\n###空指针避免方法\n\n使调用者明确知道方法的入参是否可以接受null，方法的返回值是否可以返回null。\n\n##### 返回值空指针避免\n\n1. 使用Optional\n\n- Java8前使用 Google Guava的Optional\n- Java8 引入了Optional\n\nOptional的选择和使用比较简单。但是Optional并不适用于方法入参。\n\n```\n// Java8\npublic static Optional<String> valueOf(Integer number) {\n    if (number == null) {\n        return Optional.empty();\n    }\n    String str = String.valueOf(number);\n    return Optional.of(number);\n}\n```\n\n\n\n2. 标注注解\n\n仅仅靠Optional是不够的。方法的返回类型不是Optional不能说明方法是否会返回null，因此需要一种更明确的方式。\n\n##### 方法入参控制值避免\n\n1. 标注注解\n\n### 注解的使用\n\n1. 常用的注解：\n\nfindbugs \n\n- edu.umd.cs.findbugs.annotations.NonNull\n- edu.umd.cs.findbugs.annotations.Nullable\n\njsr305 \n\n- javax.annotation.Nonnull\n- javax.annotation.Nullable\n\nspring-core \n\n- org.springframework.lang.NonNull\n- org.springframework.lang.Nullable\n\njavax-validator \n\n- javax.validation.constraints.NotNull\n- javax.validation.constraints.Null\n\nandroid-support \n\n- android.support.annotation.NonNull\n- android.support.annotation.Nullable\n\neclipse-jdt \n\n- org.eclipse.jdt.annotation.NonNull\n- org.eclipse.jdt.annotation.Nullable\n\njetbrains-annotations \n\n- org.jetbrains.annotations.NotNull\n- org.jetbrains.annotations.Nullable\n\nlombok \n\n- lombok.NonNull\n\nrt.jar \n\n- com.sun.istack.internal.NotNull\n- com.sun.istack.internal.Nullable\n\n2. 选择因素\n\n注解完备性 \n\n- 必须同时支持null注解与非null注解，如果只支持其中一个那么使用场景将会受到很大限制\n\nide代码检查 \n\n- 在ide中运行的时候如果能够对标注非null的参数和返回值进行校验，那么么将在很大程度上避免空指针\n\n- 校验逻辑大致如下:\n\n  ```\n  public static void display(@Nonnull String str) {\n      if (str == null) {\n          throw new IllegalArgumentException();\n      }\n      // do something\n  }\n  复制代码\n  ```\n\nide注解生成 \n\n- 继承父类的方法，是否可以直接继承标注在方法参数和返回类型上的注解，这个特性是很重要的，因为在大型软件系统的中都是采用分层架构，层与层之间进行调用都是通过接口，因此不支持这个特性将会导致开发人员手动在子类方法入参和返回类型上标注注解，这无疑会大大增加工作量。\n\nide智能提示 \n\n- 会对潜在产生空指针的变量进行高亮显示\n\nfindbugs支持 \n\n- 一般的公司都会要求开发人员在ide上安装findbugs，用以扫描代码分析潜在的bug\n\nsonar支持 \n\n- 大型公司都会对代码进行静态分析，一般使用SonarCube，SonarCube可以继承fingbugs和pmd的校验规则，因此支持fingdbugs可以在一定程度上说明也支持Sonar\n\n3. 各类注解支持情况\n\n| 注解支持库            | 空注解   | 非空注解  | findbugs支持 | sonar支持 | ide运行时检查 | ide智能提示 | ide代码生成 |\n| --------------------- | -------- | --------- | ------------ | --------- | ------------- | ----------- | ----------- |\n| findbugs              | @NonNull | @Nullable | 支持         | 支持      | 支持          | 支持        | 支持        |\n| jsr305                | @Nonnull | @Nullable | 支持         | 支持      | 支持          | 支持        | 支持        |\n| spring-core           | @NonNull | @Nullable | 不支持       | 不支持    | 不支持        | 支持        | 不支持      |\n| javax-validator       | @NotNull | @Null     | 不支持       | 不支持    | 不支持        | 不支持      | 支持        |\n| android-support       | @NonNull | @Nullable | 不支持       | 不支持    | 支持          | 支持        | 支持        |\n| eclipse-jdt           | @NonNull | @Nullable | 不支持       | 不支持    | 不支持        | 支持        | 支持        |\n| jetbrains-annotations | @NotNull | @Nullable | 不支持       | 不支持    | 支持          | 支持        | 支持        |\n| lombok                | @NonNull | 不支持    | 不支持       | 不支持    | 不支持        | 不支持      | 不支持      |\n| rt.jar                | @NotNull | @Nullable | 不支持       | 不支持    | 不支持        | 不支持      | 不支持      |\n\n######注意\n\n测试使用的ide是Idea，Eclipse存在一定的差异\n\nrt.jar @NotNull @Nullable属于sun的内部包，不要使用，如果有代码检查则不会被允许通过\n\neclipse-jdt和jetbrains-annotations和对应的ide绑定比较紧密不要轻易使用\n\njavax-validator和lombok主要是运行时的参数检查\n\nfingbugs原生的注解已经不再推荐，推荐使用jsr305的注解\n\n#####结论\n\n使用jsr305的注解\n\n基本类型的入参和返回值是不需要标注@Nonnull和@Nullable注解的；\n\nprivate方法，package方法，protected方法也是不需要标注的；\n\npublic方法上的非基本类型参数和返回值需要标注。\n\n### 示例\n\n* maven依赖\n\n```\n<dependency>\n    <groupId>com.google.code.findbugs</groupId>\n    <artifactId>jsr305</artifactId>\n    <version>3.0.2</version>\n</dependency>\n```\n\n* 使用示例\n\n```\n// 非空注解\n@Nonnull\npublic Integer add(@Nonnull Integer number1, @Nonnull Integer number2) {\n    Assert.notNull(number1, \"number1 must not be null\");\n    Assert.notNull(number2, \"number2 must not be null\");\n    return numnber1 + number2;\n}\n\n// 空注解\npublic static boolean isBlank(@Nullable String str) {\n    return str == null || str.trim().length() == 0;\n}\n\n// Optional\n@Nonnull\npublic static Optional<Integer> parseInte(@Nullable String str) {\n    if (str == null) {\n        return Optional.empty();\n    }\n    return Optional.of(Integer.parseInt(str));\n}\n```\n\n* Idea jsr305注解配置\n\n![Idea jsr305注解配置](https://user-gold-cdn.xitu.io/2018/9/15/165dbfd6bbbade6c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)"},{"title":"Mysql的时间比较和DATE_FORMAT踩的坑","url":"/2019/04/03/Mysql的时间比较和DATE-FORMAT踩的坑/","content":"\n### 踩坑背景：\n\n   在一次先插入数据再进行查询的业务逻辑操作过程中，有一个字段数据库类型是datetime,插入操作是在java代码中new Date(),赋值到该数据库字段进行插入，而后同同一个date作为查询条件，代入sql进行查询，神奇的事情出现了，竟然查不到刚刚插入的数据。\n\n##### 原因分析：\n\n在进行插入操作中，Mysql做了格式format，毫秒会进行处理，四舍五入的方式处理，最终存入数据库的数据毫秒位均是零，but 在进行查询的时候是不进行format的，会带有毫米位，所以绝大多数情况是查不到的，除非new Date(),恰好是整秒。\n\n##### 解决方案：\n\n对查询的date进行date_format。dete_format 的格式化方式和其他的还有差别，具体如下：\n\n| 格式 | 描述                                           |\n| ---- | ---------------------------------------------- |\n| %a   | 缩写星期名                                     |\n| %b   | 缩写月名                                       |\n| %c   | 月，数值                                       |\n| %D   | 带有英文前缀的月中的天                         |\n| %d   | 月的天，数值(00-31)                            |\n| %e   | 月的天，数值(0-31)                             |\n| %f   | 微秒                                           |\n| %H   | 小时 (00-23)                                   |\n| %h   | 小时 (01-12)                                   |\n| %I   | 小时 (01-12)                                   |\n| %i   | 分钟，数值(00-59)                              |\n| %j   | 年的天 (001-366)                               |\n| %k   | 小时 (0-23)                                    |\n| %l   | 小时 (1-12)                                    |\n| %M   | 月名                                           |\n| %m   | 月，数值(00-12)                                |\n| %p   | AM 或 PM                                       |\n| %r   | 时间，12-小时（hh:mm:ss AM 或 PM）             |\n| %S   | 秒(00-59)                                      |\n| %s   | 秒(00-59)                                      |\n| %T   | 时间, 24-小时 (hh:mm:ss)                       |\n| %U   | 周 (00-53) 星期日是一周的第一天                |\n| %u   | 周 (00-53) 星期一是一周的第一天                |\n| %V   | 周 (01-53) 星期日是一周的第一天，与 %X 使用    |\n| %v   | 周 (01-53) 星期一是一周的第一天，与 %x 使用    |\n| %W   | 星期名                                         |\n| %w   | 周的天 （0=星期日, 6=星期六）                  |\n| %X   | 年，其中的星期日是周的第一天，4 位，与 %V 使用 |\n| %x   | 年，其中的星期一是周的第一天，4 位，与 %v 使用 |\n| %Y   | 年，4 位                                       |\n| %y   | 年，2 位                                       |\n\n务必注意分钟是%i\n\n##### 示例\n\n```\nDATE_FORMAT(NOW(),'%b %d %Y %h:%i %p')\nDATE_FORMAT(NOW(),'%m-%d-%Y')\nDATE_FORMAT(NOW(),'%d %b %y')\nDATE_FORMAT(NOW(),'%d %b %Y %T:%f')\n```\n\n结果\n\n```\nDec 29 2008 11:45 PM\n12-29-2008\n29 Dec 08\n29 Dec 2008 16:25:46.635\n```\n\n"},{"title":"MySQL语句中IN和EXISTS的区别和使用场景","url":"/2019/04/01/MySQL语句中IN和EXISTS的区别和使用场景/","content":"## MySQL SQL语句中IN 和 EXISTS的区别和使用场景\n\n转载：https://blog.csdn.net/wqc19920906/article/details/79800374\n\n### IN 语句：只执行一次\n\n确定给定的值是否与子查询或列表中的值相匹配。\n\nin在查询的时候，首先查询子查询的表，然后将内表和外表做一个笛卡尔积，然后按照条件进行筛选。所以相对内表比较小的时候，in的速度较快。\n\n### EXISTS语句：执行外表结果.length次\n\n指定一个子查询，检测行的存在。遍历循环外表，然后看外表中的记录有没有和内表的数据一样的。匹配上就将结果放入结果集中。\n\n使用exists关键字进行查询的时候，首先，我们先查询的不是子查询的内容，而是查我们的主查询的表。\n\n然后，根据表的每一条记录，执行以下语句，依次去判断where后面的条件是否成立。\n\n如果成立则返回true不成立则返回false。如果返回的是true的话，则该行结果保留，如果返回的是false的话，则删除该行，最后将得到的结果返回。\n\n### 区别及应用场景\n\nin 和 exists的区别: \n\n1. 如果子查询得出的结果集记录较少，主查询中的表较大且又有索引时应该用in。\n2.  反之如果外层的主查询记录较少，子查询中的表大，又有索引时使用exists。\n3. 其实我们区分in和exists主要是造成了驱动顺序的改变(这是性能变化的关键)，如果是exists，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询，所以我们会以驱动表的快速返回为目标，那么就会考虑到索引及结果集的关系了 。\n4. IN时不对NULL进行处理。\n5. in 是把外表和内表作hash 连接，而exists是对外表作loop循环，每次loop循环再对内表进行查询。\n6. 一直以来认为exists比in效率高的说法是不准确的。\n\n### not in 和not exists\n\n​    如果查询语句使用了not in 那么内外表都进行全表扫描，没有用到索引；而not extsts 的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。\n\n### 场景示例\n\n1. IN 查询示例\n\n```\nselect * from A\nwhere id in(select id from B)\n```\n\n查询过程类似于以下过程\n\n```\nList resultSet=[];\nArray A=(select * from A);\nArray B=(select id from B);\n\nfor(int i=0;i<A.length;i++) {\n   for(int j=0;j<B.length;j++) {\n      if(A[i].id==B[j].id) {\n         resultSet.add(A[i]);\n         break;\n      }\n   }\n}\nreturn resultSet;\n```\n\n2. exists 查询示例\n\n```\nselect a.* from A a \nwhere exists(select 1 from B b where a.id=b.id)\n```\n\n查询过程类似于以下过程\n\n```\nList resultSet=[];\nArray A=(select * from A)\n\nfor(int i=0;i<A.length;i++) {\n   if(exists(A[i].id) {    //执行select 1 from B b where b.id=a.id是否有记录返回\n       resultSet.add(A[i]);\n   }\n}\nreturn resultSet;\n```\n\n3. exists 在子查询中使用 NULL 仍然返回结果集\n\nselect * from TableIn where exists(select null)\n等同于： select * from TableIn\n\n4. \n\n```\nusers表有1000条记录，id自增，id都大于0\n\nselect * from users where exists (select * from users limit 0); --输出1000条记录\n\nselect * from users where exists (select * from users where id < 0); --输出0条记录\n```\n\nexists查询的本质，只要碰到有记录，则返回true；所以limit根本就不会去管，或者说执行不到。\n\n5. exists不可以完全代替in\n\n```\n--没有关联字段的情况：枚举常量\nselect * from areas where id in (4, 5, 6);\n\n--没有关联字段的情况：这样exists对子查询，要么全true，要么全false\nselect * from areas where id in (select city_id from deals where deals.name = 'xxx'); \n```\n\n6. exists 优化\n\n在许多基于基础表的查询中，为了满足一个条件，往往需要对另一个表进行联接。 \n在这种情况下，使用exists(或not exists)通常将提高查询的效率。\n\n```\n（低效） \nselect ... from table1 t1 where t1.id > 10 and pno in (select no from table2 where name like 'www%'); \n（高效） \nselect ... from table1 t1 where t1.id > 10 and exists (select 1 from table2 t2 where t1.pno = t2.no and name like 'www%'); \n```\n\n7. 用not exists替代not in\n\n在子查询中，not in子句将执行一个内部的排序和合并。 \n无论在哪种情况下，not in都是最低效的 (因为它对子查询中的表执行了一个全表遍历)。 \n为了避免使用not in，我们可以把它改写成外连接(Outer Joins)或not exists。 \n\n8. 用exists替换distinct\n\n当提交一个包含一对多表信息的查询时,避免在select子句中使用distinct. 一般可以考虑用exists替换 \n\nexists使查询更为迅速,因为RDBMS核心模块将在子查询的条件一旦满足后,立刻返回结果.\n\n```\n（低效） \nselect distinct d.dept_no, d.dept_name from t_dept d, t_emp e where d.dept_no = e.dept_no; \n（高效） \nselect d.dept_no, d.dept_name from t_dept d where exists (select 1 from t_emp where d.dept_no = e.dept_no); \n```\n\n9. 用表连接替换exists\n\n```\n（低效） \nselect ename from emp e where exists (select 1 from dept where dept_no = e.dept_no and dept_cat = 'W'); \nSELECT ENAME \n（高效） \nselect ename from dept d, emp e where e.dept_no = d.dept_no and dept_cat = 'W'; \n```\n\n"},{"title":"echoip步骤","url":"/2019/03/18/Contos 环境 Docker安装echoip步骤/","content":"\n## Contos 环境 Docker安装 **echoip**步骤\n\n背景：因为最近的一些个人的想法，恰好需要使用根据Ip获取地理位置，在百度和Google中查询了很多种接口，要么收费，要么有次数限制，萌新囊中羞涩，故而使用https://github.com/mpolden/echoip 这个服务了，并且使用了Docker 部署的方式进行使用。在部署过程中踩了很多坑，故进而记录，以防以后使用。\n\n### 环境准备\n\n#### 首先要安装docker环境，并运行起来。\n\n```\nuname -r\n```\n\nDocker 要求 CentOS 系统的内核版本高于 3.10 ，查看本页面的前提条件来验证你的CentOS 版本是否支持 Docker 。\n\n安装一些必要的系统工具\n\n```\nsudo yum install -y yum-utils device-mapper-persistent-data lvm2\n```\n\n添加软件源信息：\n\n```\nsudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n```\n\n更新 yum 缓存：\n\n```\nsudo yum makecache fast\n```\n\n安装 Docker-ce：\n\n```\nsudo yum -y install docker-ce\n```\n\n启动 Docker 后台服务\n\n```\nsudo systemctl start docker\n```\n\n测试运行 hello-world\n\n```\ndocker run hello-world\n```\n\n#### 安装git\n\n```\nsudo yum install git\n```\n\n安装Vim\n\n```\nsudo yum install vim\n```\n\n\n\n### Install docker-ce\n\nClone the project\n\n```\ngit clone https://github.com/alaluces/Docker-EchoIP.git echoip\ncd echoip\n```\n\nDownload the geoip db and extract to geoip folder\n\n```\ncd geoip\nwget https://geolite.maxmind.com/download/geoip/database/GeoLite2-City.tar.gz\nwget https://geolite.maxmind.com/download/geoip/database/GeoLite2-Country.tar.gz\ntar xvf GeoLite2-City.tar.gz\ntar xvf GeoLite2-Country.tar.gz\nmv GeoLite2-City_20190318/GeoLite2-City.mmdb ..\nmv GeoLite2-Country_20190318/GeoLite2-Country.mmdb ..\n\n```\n\nEdit the startup script to modify your preferences\n\n```\nvim start.sh\n\nApplication Options:\n  -f, --country-db=FILE        Path to GeoIP country database\n  -c, --city-db=FILE           Path to GeoIP city database\n  -l, --listen=ADDR            Listening address (default: :8080)\n  -r, --reverse-lookup         Perform reverse hostname lookups\n  -p, --port-lookup            Enable port lookup\n  -t, --template=FILE          Path to template (default: index.html)\n  -H, --trusted-header=NAME    Header to trust for remote IP, if present (e.g. X-Real-IP)\n\nHelp Options:\n  -h, --help                   Show this help message\n```\n\nBuild the container\n\n```\ndocker build -t echoip .\n```\n\nRun the image you built\n\n```\ndocker run -d --rm --name echoip -p8080:8080 echoip\n```\n\nIf built successfully, it can be viewed on:\n\n```\nhttp://ip:8080/json\n```\n\n![gratisography-ski-lift-summer.jpg](https://i.loli.net/2019/03/18/5c8fb80fb113e.jpg)"},{"title":"2019，重新开始","url":"/2019/03/14/2019，重新开始/","content":"\n##                                 2019，重新开始\n\n​    2019，北漂第四年，重新选择，重新开始。要做的事情很多，之前的想法要在这一年中一件一件的实现，首先就是创建一个自己的博客，虽然，有这个想法有好长时间，一直没有落地，终于在昨天把博客搭建起来了，算一个开始。"}]